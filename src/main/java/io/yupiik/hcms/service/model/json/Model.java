/*
 * Copyright (c) 2024 - present - Yupiik SAS - https://www.yupiik.com
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package io.yupiik.hcms.service.model.json;

import io.yupiik.fusion.framework.build.api.configuration.Property;
import io.yupiik.fusion.framework.build.api.json.JsonModel;
import java.util.List;
import java.util.Map;

@JsonModel
public record Model(
        @Property(documentation = "Should `/openrpc.json` endpoint be enabled.", defaultValue = "true")
                Boolean enableOpenRPC,
        @Property(documentation = "Should `/openapi.json` endpoint be enabled.", defaultValue = "true")
                Boolean enableOpenAPI,
        @Property(
                        documentation =
                                "Should `/swagger-ui/` endpoint be enabled, ensure to also set `enableOpenAPI` to `true`.",
                        defaultValue = "true")
                Boolean enableSwaggerUI,
        @Property(documentation = "List of SQL scripts to execute at model load time.") List<String> sql,
        @Property(documentation = "Entities to define and make available for JSON-RPC methods.")
                List<EntitySpec> entities,
        @Property(documentation = "JSON-RPC methods to register.") List<JsonRpcMethod> jsonRpcMethods,
        @Property(
                        documentation =
                                "OpenRPC partial object, should generally set the `info` entry at least, likely `servers` and maybe `externalDocs`. See link:https://spec.open-rpc.org/#introduction[OpenRPC] specification.")
                Map<String, Object> partialOpenRPC) {
    @JsonModel
    public record EntitySpec(
            @Property(documentation = "Entity name - identifier.") String name,
            @Property(documentation = "Database table name.") String tableName,
            @Property(
                            documentation =
                                    "If `true` we consider the identifiers are generated at create time - ensure your DDL is accurate if so.")
                    boolean autoGeneratedIds,
            @Property(
                            documentation =
                                    "Field generated at `create` time. It is often used for audit (`datetime`) and id fields (`uuid`). Only relevant for `CRUD` method type.")
                    Map<String, GenerationType> generatedCreateFields,
            @Property(
                            documentation =
                                    "Field generated at `update` time. It is often used for audit (`datetime`). Only relevant for `CRUD` method type.")
                    Map<String, GenerationType> generatedUpdateFields,
            @Property(
                            documentation =
                                    "List of (JSON) properties which are enabled to sort the `findAll` result set if enabled")
                    List<String> allowedSortKeys,
            @Property(
                            documentation =
                                    "List of (JSON) properties which are enabled to filter the `findAll` result set if enabled (where clause)")
                    List<String> allowedWhereKeys,
            @Property(
                            documentation =
                                    "The where operators which can be used in `filters` payload for `findAll` methods if enabled, using `default` enables main database ones. "
                                            + "Not setting it will only enable `=` by default. "
                                            + "Text - `like` operator for example, is tested in lower case.")
                    List<String> allowedWhereOperators,
            @Property(
                            documentation =
                                    "Name of the field used to manage the versioning. "
                                            + "If not set there is no revision (only a _snapshot_ of the entity). "
                                            + "If set the targetting field if should target either a number or a date (`type=string` and `format=date-time`) field. "
                                            + "In such a case, the field is 100% managed by HCMS and is not writable by the client.")
                    String revisionProperty,
            @Property(
                            documentation =
                                    "How to transform properties name to get database names from JSON-RPC ones. No-op if ignored.")
                    DatabaseToJsonTransformationType naming,
            @Property(
                            documentation =
                                    "List of properties representing the identifiers of the entity - JSON names, if ignored and properties has an `id` entry it will be used as identifier.")
                    List<String> identifierNames,
            @Property(
                            documentation =
                                    "Simplified JSON-Schema definition for the entity and JSON-RPC related endpoints.")
                    JsonSchema jsonSchema,
            @Property(
                            documentation =
                                    "For `create` and `update` endpoints if relevant, should they be validated with `jsonSchema`. "
                                            + "In such a case only the named binding of JSON-RPC is supported, not the array mode. "
                                            + "Also take care to virtual fields which will be validated too.")
                    boolean validateWithJsonSchema,
            @Property(
                            documentation =
                                    "Implicit where clause entries, note that create will need to use `security` since there is no entity context there.")
                    EntityImplicitFiltering implicitFiltering) {}

    @JsonModel
    public record EntityImplicitFiltering(
            @Property(
                            documentation =
                                    "Where clause (without `WHERE` keyword) to add to `findById` and `findAll`, it can use `user.xxx` to access field `xxx` of the JWT if it is there (else `null` will be used).")
                    ImplicitFiltering view,
            @Property(
                            documentation =
                                    "Where clause (without `WHERE` keyword) to add to `update`, it can use `user.xxx` to access field `xxx` of the JWT if it is there (else `null` will be used).")
                    ImplicitFiltering update,
            @Property(
                            documentation =
                                    "Where clause (without `WHERE` keyword) to add to `delete`, it can use `user.xxx` to access field `xxx` of the JWT if it is there (else `null` will be used).")
                    ImplicitFiltering delete) {}

    @JsonModel
    public record ImplicitFiltering(
            @Property(
                            documentation = "Filtering clause(s), ex: `status = 'PUBLISHED' OR author = {{user.sub}}`. "
                                    + "The placeholders use handlebars syntax. "
                                    + "`user` represents the contextual JWT.")
                    String clause) {}

    @JsonModel
    public enum GenerationType {
        @Property(documentation = "use a random `UUID`")
        uuid,

        @Property(documentation = "use current date time with timezone")
        datetime,

        @Property(
                documentation =
                        "use current authenticated user login, important: ensure to make the related method authenticated if required else null be used (anonymous access)!")
        sub
    }

    @JsonModel
    public enum DatabaseToJsonTransformationType {
        @Property(
                documentation =
                        "convert camel case (`fooBar`) on JSON-RPC side to snake case (`foo_bar`) on database side")
        CAMEL_TO_SNAKE
    }

    @JsonModel
    public record JsonRpcMethod(
            @Property(documentation = "Type of JSON-RPC method generation.") JsonRpcMethodType type,
            @Property(documentation = "Name of the entity to use to generate the JSON-RPC methods.") String entityName,
            @Property(documentation = "OpenRPC description.", defaultValue = "\"\"") String description,
            @Property(
                            documentation =
                                    "Security model for this method(s) registration(s). If not set, default is equivalent to anonymous access.")
                    JsonRpcMethodSecurity security) {}

    @JsonModel
    public record SecurityValidation(
            @Property(documentation = "Can anyone call the endpoint without any validation, not even a JWT.")
                    boolean anonymous,
            @Property(documentation = "Can anyone authenticated call this endpoint - requires a valid JWT.")
                    boolean logged,
            @Property(
                            documentation =
                                    "Requires one of this list roles to be in the roles of the JWT. "
                                            + "At least one role from the JWT (`roles` array) must match this list of role if set. "
                                            + "The values is considered as a constant - like `user:admin`. "
                                            + "For dynamic filtering (like 'only find my posts'), prefer using entity filtering and the database directly.")
                    List<String> roles) {}

    @JsonModel
    public record JsonRpcMethodSecurity(
            @Property(documentation = "Security for view access (`findById`, `findAll` endpoints).")
                    SecurityValidation view,
            @Property(documentation = "Security for creation access (`create` endpoint).") SecurityValidation create,
            @Property(documentation = "Security for creation access (`update` endpoint).") SecurityValidation update,
            @Property(documentation = "Security for deletion access (`deleteById` endpoint).")
                    SecurityValidation delete) {}

    @JsonModel
    public enum JsonRpcMethodType {
        @Property(
                documentation = "generate `create`, `update`, `findById`, `findAll` and `deleteById` JSON-RPC methods")
        CRUD,

        @Property(documentation = "only generate `findAll` JSON-RPC method")
        FIND_ALL,

        @Property(documentation = "only generate `create` JSON-RPC method")
        CREATE,

        @Property(documentation = "only generate `update` JSON-RPC method")
        UPDATE,

        @Property(documentation = "only generate `findById` JSON-RPC method")
        FIND_BY_ID,

        @Property(documentation = "only generate `deleteById` JSON-RPC method")
        DELETE_BY_ID
    }

    @JsonModel
    public record JsonSchema(
            @Property(
                            documentation =
                                    "Type for the schema, for entities it is normally `object`. This is a list to allow to create `null` to make it nullable.")
                    List<JsonSchemaType> type,

            // object properties
            @Property(
                            documentation =
                                    "For `objects`, the properties - for entities ensure to use primitives as children.")
                    Map<String, JsonSchema> properties,

            // array properties
            @Property(documentation = "As of today defining an array is not supported, will come in the future.")
                    JsonSchema items,

            // array properties
            @Property(documentation = "Required attributes for objects.") List<String> required,

            // number properties
            @Property(documentation = "For `numbers`/`integer`.") Integer multipleOf,
            @Property(documentation = "For `numbers`/`integer`.") Double minimum,
            @Property(documentation = "For `numbers`/`integer`.") Double maximum,
            @Property(documentation = "For `numbers`/`integer`.") Double exclusiveMinimum,
            @Property(documentation = "For `numbers`/`integer`.") Double exclusiveMaximum,

            // string validations
            @Property(documentation = "For `string`.") Integer minLength,
            @Property(documentation = "For `string`.") Integer maxLength,
            @Property(documentation = "For `string`.") String pattern,
            @Property(documentation = "For `string`.") JsonSchemaFormat format) {}

    @JsonModel
    public enum JsonSchemaFormat { // https://json-schema.org/understanding-json-schema/reference/string
        date_time,
        time,
        date,
        duration,
        email,
        hostname,
        ipv4,
        ipv6,
        uuid,
        uri,
        json_pointer,
        regex;

        public String toJsonString() {
            return name().replace('_', '-');
        }
    }

    @JsonModel
    public enum JsonSchemaType {
        @Property(documentation = "defines an object, not yet supported for entities properties")
        object,

        @Property(documentation = "defines a number, likely a floating one")
        number,

        @Property(documentation = "defines an integer")
        integer,

        @Property(documentation = "defines a string value - or a date/time/uri")
        string,

        @Property(documentation = "defines a boolean")
        bool,

        @Property(documentation = "defines an array, not yet supported for entities properties")
        array,

        @Property(
                documentation = "defines null, there is no valid use case for it, there just for completion of the set")
        nullValue;

        public String toJsonString() {
            return switch (this) {
                case bool -> "boolean";
                case nullValue -> "null"; // unlikely to be useful
                default -> name();
            };
        }
    }
}
